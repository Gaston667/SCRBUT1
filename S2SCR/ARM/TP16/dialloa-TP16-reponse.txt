------- SCR.2.1 TP 16 -------

------- Question 1 ----------

    dialloa@rp70:~/SCR/S2SCR/ARM/TP16$ uname -m
    aarch64

    Explication: On constate que la machine a un os de 64 bits

------- Question 2 ----------
    dialloa@rp70:~/SCR/S2SCR/ARM/TP16$ lscpu
    Architecture:                    aarch64
    CPU op-mode(s):                  32-bit, 64-bit
    Byte Order:                      Little Endian
    CPU(s):                          4
    On-line CPU(s) list:             0-3
    Thread(s) per core:              1
    Core(s) per socket:              4
    Socket(s):                       1
    Vendor ID:                       ARM
    Model:                           4
    Model name:                      Cortex-A53
    Stepping:                        r0p4
    CPU max MHz:                     1200.0000
    CPU min MHz:                     600.0000


    Explication: On constate que le système est 64 bits, et qu’il utilise l’architecture ARM64 (aarch64).


#include <unistd.h>
#include <stdlib.h>

int main(void){
    write(1, "Hello World!\n", 13);
    exit(0);
}


Explication:    
    write(1, ...) : appelle le système pour écrire dans la sortie standard (1).
    "Hello World!\n" : la chaîne à écrire
    13 : le nombre d’octets à écrire (13 caractères)
    exit(0) : termine proprement le programme
    Ce programme c appelle directement les syscalls (write et exit) sans utiliser la bibliothèque standard comme printf.


L’équivalent assembleur est :

.equ SYS_EXIT, 93
.equ SYS_WRITE, 64

.data
msg: .asciz "Hello World!\n"

.text
.globl _start
_start:
    mov x0, #1         // 1 sortie standard (stdout)
    adr x1, msg        // x1 contient l’adresse de la chaîne
    mov x2, #13        // longueur du message
    mov w8, #SYS_WRITE // appel système WRITE (numéro 64)
    svc #0             // exécute le syscall

    mov x0, #0         // code de retour
    mov w8, #SYS_EXIT  // appel système EXIT (numéro 93)
    svc #0

Explication :
    x0, x1, x2 sont les registres où l’on place les arguments du syscall
    w8 contient le numéro du syscall
    svc #0 déclenche le supervise call (appel système)

--------- Question 3 --------------------

    $ as -gstabs -o printHW.o printHW.s
    Utilise l’assembleur pour générer un fichier objet printHW.o
    gstabs inclut les symboles de debug (pour GDB)

    $ld -O0 printHW.o
    Utilise le linker pour générer l’exécutable a.out


-------- Question 4 -------------------------

Lancement de GDB :
gdb a.out

run : lance l'exécution
b 12 : pose un breakpoint à la ligne 12 (mov x0, #1)
i r x0 x1 x2 w8 : affiche le contenu des registres
x /s adresse : affiche la chaîne de caractères à une adresse mémoire
s / step : exécute une instruction
c / continue : continue l’exécution jusqu’à la fin

Registres x0, x1, x2 contiennent respectivement : descripteur de fichier (1), adresse de la chaîne, longueur (13).
w8 contient le numéro du syscall
svc #0 déclenche l’appel système (WRITE ou EXIT)








------------------------------------------------
Ficher miniml:

/*
Lines enclosed here are comments
A small program: prints "Hello World!"
*/

// From // to the end of this line is a comment: next are directives to the assembler
    .equ SYS_EXIT, 93
    .equ SYS_WRITE, 64

    .data // tells assembler to assemble the following in the data section

    // in the text (code) section
    .globl _start // _start is there where the program starts,
                  // .globl makes it visible to the linker

_start:
       

mov x0, #0     // in x0 put the value you want to exit with
mov w8,#SYS_EXIT
svc #0
.end





Rappe: 
    +Le descripteur de ficher  associe à 
        -> la sortie standar des erreurs est le numero 2 (2>/dev/null).
        -> la sortie standar des résultat est le numero 1.
        -> la sortie standar est le numero 0.

Note:
    Pensez à placer dans un répertoire ARM tous les fichiers concernant des programmes ARM.
    Pour les commande ld, gdb et les execution de programmes ARM, il faut se connecte par ssh à 172.16.3.170
Sémentique de l'appelle systeme write qui est codé en c.
On fais man 2 write pour voir la doc
pourquoi le 2 car c'est le write de la section 2 de la page manuelle qui nous interesse, le write codé en c.

    write(x; y; z)
        x -> entier: on met ici le descripteur de ficher qu'il faut
        y -> buf qii continet l'adresse dans la memoire du processus, adresser où se trouve les octets à écrire
        z -> le nombre d'octet a ecrire en les considerant à partir du buf.