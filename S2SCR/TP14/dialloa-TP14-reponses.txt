Algassimou pelle diallo  TP14

---------------------------------- Question 1----------------------------------------------
    CMD1: [dialloa@vm-dialloa TP14]$ ncat -lu 50000
    Explication: 
        La commande ncat -lu 50000 d√©marre un serveur UDP (-u) qui 
        √©coute en mode listen (-l) sur le port 50000. 
        Cela veut dire qu'il est pr√™t √† recevoir des donn√©es sur ce port.

    Cmd2: [dialloa@vm-dialloa ~]$ ss -unlp | grep 50000
    UNCONN 0      0                                  0.0.0.0:50000      0.0.0.0:*    users:(("ncat",pid=5542,fd=4))
    UNCONN 0      0                                     [::]:50000         [::]:*    users:(("ncat",pid=5542,fd=3))

    Explication: La commande ss est utilis√©e pour afficher les connexions r√©seau. 
    Les options -u, -n, -l, et -p signifient respectivement :
    -u : afficher les sockets UDP.
    -n : ne pas r√©soudre les noms d'h√¥tes ou les ports (affichage sous forme num√©rique).
    -l : afficher uniquement les sockets en √©coute.
    -p : afficher les processus associ√©s √† chaque socket.
    Le r√©sultat montre que ncat est bien en √©coute sur le port 50000 
    sur toutes les interfaces (0.0.0.0:50000 pour IPv4 et [::]:50000 pour IPv6).

    Cmd3: [dialloa@vm-dialloa ~]$ ncat -u 127.0.0.1 50000
    
    Explication:
        Dans une seconde fenetre on lance Cette commande qui lance un client UDP en envoyant 
        des donn√©es au serveur ncat qui √©coute sur 127.0.0.1 (loopback) sur le port 50000.
        Le -u indique que la communication est en mode UDP.


---------------------------------- Question 2 ----------------------------------------------
    cmd1: [dialloa@vm-dialloa TP14]$ dd if=/dev/urandom of=ft-file.dat bs=1K count=9
        9+0 records in
        9+0 records out
        9216 bytes (9.2 kB, 9.0 KiB) copied, 0.00416161 s, 2.2 MB/s

    cmd2: [dialloa@vm-dialloa TP14]$ ls -l ft-file.dat 
        -rw-r--r-- 1 dialloa info-etu-but-2024 9216 Mar  5 11:13 ft-file.dat
    
    Explication: 
    Dans un troisi√®me terminal on construit par dd un fichier de taille 9K k=1024
    J'ai fait un ls pour verifier que le fichier √† bien √©t√© contruit et il contient bien des donn√©e aleatoire avec la bonne taille 
    et il a bien la bonne taille.
    
    voici les 80 premier octet:
        a330 aecd 1eb6 7412 e0bb 91fb 9387 51ad
        d042 0bdc 4d31 8455 d0cc 684b e6f3 4614
        6d10 0e8d 87ba 0290 71fb 7c06 d80a c756
        92f9 e25b c873 1c11 8558 26bc d2e3 8e6e
        dcd8 6643 e1b6 c269 961d 0cad 8fb8 f7b8

    Cmd3: [dialloa@vm-dialloa TP14]$ tcpdump -i lo -ntlv udp port 50000

    Explication: 
    La commande tcpdump permet de capturer le trafic r√©seau. Ici, nous utilisons :
    -i lo : pour capturer les paquets sur l'interface de boucle locale (loopback).
    -ntlv : pour ne pas r√©soudre les noms d'h√¥tes (-n), afficher les paquets avec plus de d√©tails (-v),
            et afficher les timestamps (-t).
    udp port 50000 : pour ne capturer que les paquets UDP sur le port 50000.

    Cela permet de v√©rifier les paquets UDP √©chang√©s.


---------------------------------- Question 3- ----------------------------------------------
Cmd: [dialloa@vm-dialloa TP14]$ ncat -u 127.0.0.1 50000 < ft-file.dat 
        Cette commande envoie le fichier ft-file.dat au serveur ncat qui √©coute sur le port UDP 50000. 
        Le fichier est envoy√© via UDP √† 127.0.0.1 (localhost).


    Resultat du tcpdump: 
        [dialloa@vm-dialloa TP14]$ tcpdump -i lo -ntlv udp port 50000
        tcpdump: listening on lo, link-type EN10MB (Ethernet), snapshot length 262144 bytes
        IP (tos 0x0, ttl 64, id 21888, offset 0, flags [DF], proto UDP (17), length 8220)
            127.0.0.1.56743 > 127.0.0.1.50000: UDP, length 8192
        IP (tos 0x0, ttl 64, id 21889, offset 0, flags [DF], proto UDP (17), length 1052)
            127.0.0.1.56743 > 127.0.0.1.50000: UDP, length 1024
        
    Explication:
        Le trafic capture montre deux paquets UDP :
            Le premier paquet a une taille de 8192 octets.
            Le second paquet a une taille de 1024 octets.
        La somme de ces deux paquets est √©gale √† 9216 octets, la taille du fichier.
        Ce n'est pas une fragmentation, car le flag MF (More Fragments) n'est pas activ√©, 
        ce qui signifie que les paquets sont envoy√©s s√©par√©ment selon la taille du tampon d'envoi de ncat.

---------------------------------- Question 4 -----------------------------------------------
    Cmd1: ncat -lu 50000 > toto
        Explication1:
        Lance un serveur UDP sur le port 50000, et les donn√©es re√ßues sur ce port sont enregistr√©es dans le fichier toto.

    Cmd2: [dialloa@vm-dialloa TP14]$ tcpdump -i enp6s18 -netvvv host 172.16.10.19 and host 172.16.10.40 and udp and not arp
        Explication2:
        La commande tcpdump capture le trafic r√©seau entre les h√¥tes 172.16.10.19 et 172.16.10.40 
        en filtrant les paquets UDP et en excluant les paquets ARP. 
        Cela permet de surveiller les √©changes UDP entre ces deux machines.

    Cmd3: ncat -u 172.16.10.40 < ft-file.data(sur la machine du voiosin)
        Explication3:
        Cette commande envoie le fichier ft-file.dat via UDP √† l'adresse IP 172.16.10.40. La machine source envoie les donn√©es, 
        et la machine cible re√ßoit les donn√©es sur le port UDP 50000, o√π ncat est en √©coute.


    Resultat du TCPDUMP:
        tcpdump: listening on enp6s18, link-type EN10MB (Ethernet), snapshot length 262144 bytes
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 1514: (tos 0x0, ttl 64, id 4174, offset 0, flags [+], proto UDP (17), length 1500)
            172.16.10.19.53338 > 172.16.10.40.50000: UDP, length 8192
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 1514: (tos 0x0, ttl 64, id 4174, offset 1480, flags [+], proto UDP (17), length 1500)
            172.16.10.19 > 172.16.10.40: ip-proto-17
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 1514: (tos 0x0, ttl 64, id 4174, offset 2960, flags [+], proto UDP (17), length 1500)
            172.16.10.19 > 172.16.10.40: ip-proto-17
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 1514: (tos 0x0, ttl 64, id 4174, offset 4440, flags [+], proto UDP (17), length 1500)
            172.16.10.19 > 172.16.10.40: ip-proto-17
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 1514: (tos 0x0, ttl 64, id 4174, offset 5920, flags [+], proto UDP (17), length 1500)
            172.16.10.19 > 172.16.10.40: ip-proto-17
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 834: (tos 0x0, ttl 64, id 4174, offset 7400, flags [none], proto UDP (17), length 820)
            172.16.10.19 > 172.16.10.40: ip-proto-17
        bc:24:11:d0:5a:5d > bc:24:11:ce:79:c2, ethertype IPv4 (0x0800), length 1066: (tos 0x0, ttl 64, id 4175, offset 0, flags [DF], proto UDP (17), length 1052)
            172.16.10.19.53338 > 172.16.10.40.50000: [bad udp cksum 0x7075 -> 0xda06!] UDP, length 1024

    Explication du TCPDUMP: 
    Le tcpdump montre que les paquets UDP envoy√©s par 172.16.10.19 vers 172.16.10.40 sont de taille 1500 octets (maximum de la MTU Ethernet). 
    Cela signifie que les donn√©es sont fragment√©es en plusieurs paquets UDP, car chaque paquet UDP est limit√© √† 1500 octets dans ce cas.
    Les paquets suivants sont envoy√©s avec des offsets diff√©rents, indiquant qu'il s'agit d'une 
    fragmentation (le flag + indique la pr√©sence de fragments suppl√©mentaires).


------------------------------------ EXO 2 (II) -------------------------------------------

---------------------------------- Question 1 (II) ----------------------------------------
[dialloa@vm-dialloa ~]$ traceroute
bash: traceroute: command not found
[dialloa@vm-dialloa ~]$ tracepath

Usage
  tracepath [options] <destination>

Options:
  -4             use IPv4
  -6             use IPv6
  -b             print both name and IP
  -l <length>    use packet <length>
  -m <hops>      use maximum <hops>
  -n             no reverse DNS name resolution
  -p <port>      use destination <port>
  -V             print version and exit
  <destination>  DNS name or IP address

For more details see tracepath(8).

Explication: On remarque que traceroute n'est pas intaller car on a une sortie "commande not found".


---------------------------------- Question 2 (II) ----------------------------------------


tcpdump -i any -w tracepath-trace.txt -vvv '(src host <votre-IP> or dst host <votre-IP>)'


ici:

Question 1 (II)

[dialloa@vm-dialloa ~]$ traceroute
bash: traceroute: command not found

[dialloa@vm-dialloa ~]$ tracepath
Usage
  tracepath [options] <destination>

Options:
  -4             use IPv4
  -6             use IPv6
  -b             print both name and IP
  -l <length>    use packet <length>
  -m <hops>      use maximum <hops>
  -n             no reverse DNS name resolution
  -p <port>      use destination <port>
  -V             print version and exit
  <destination>  DNS name or IP address

Explication :
La commande traceroute n'est pas install√©e sur le syst√®me, on obtient une erreur "command not found".
On utilise donc tracepath, qui est une alternative int√©gr√©e sur certaines distributions Linux. Elle permet aussi de tracer le chemin des paquets vers une destination IP ou un nom DNS.
‚úÖ Question 2 (II)

[dialloa@vm-dialloa ~]$ sudo tcpdump -i any -w tracepath-trace.txt -vvv '(src host 172.16.10.19 or dst host 172.16.10.19)'

Explication :
Cette commande lance tcpdump pour capturer tout le trafic r√©seau impliquant l'adresse IP 172.16.10.19, c‚Äôest-√†-dire la machine de Diallo.

    -i any : capture sur toutes les interfaces r√©seau (ethernet, loopback, wifi, etc.).

    -w tracepath-trace.txt : sauvegarde la capture dans un fichier pour analyse ult√©rieure.

    -vvv : affiche un niveau de d√©tail maximal.

    Le filtre (src host ... or dst host ...) : s√©lectionne uniquement les paquets o√π Diallo est soit l‚Äô√©metteur soit le r√©cepteur.

Cette √©tape est pr√©paratoire, elle permet d‚Äôenregistrer les paquets qui vont √™tre g√©n√©r√©s par tracepath dans la question suivante.

Tu veux que je continue √† traiter les questions 3 et 4 (II) aussi dans ce format ?
You said:
continue sur tout le II
ChatGPT said:

Super ! Je continue tout le reste de l'EXO 2 (II) dans le m√™me format clair : commande + explication, jusqu‚Äô√† la fin.
------------------------------------ EXO 2 (II) (suite) -------------------------------------------
‚úÖ Question 3 (II)

[dialloa@vm-dialloa ~]$ tracepath -n www.google.fr

Explication :
On lance la commande tracepath vers la destination www.google.fr.

    L‚Äôoption -n permet d‚Äôafficher uniquement les adresses IP, sans essayer de r√©soudre les noms de domaine (c‚Äôest plus rapide et plus lisible).

Cette commande envoie plusieurs paquets IP avec des TTL croissants pour d√©couvrir le chemin (les routeurs) que prend un paquet pour atteindre Google.
C‚Äôest une alternative l√©g√®re √† traceroute.
‚úÖ Question 4 (II)
√âtape 1 ‚Äì Lire les paquets captur√©s dans tcpdump

[dialloa@vm-dialloa ~]$ tcpdump -r tracepath-trace.txt -vvv

Explication :
On lit le fichier tracepath-trace.txt qui contient le trafic captur√© pendant l‚Äôex√©cution de tracepath.
Le flag -vvv permet d‚Äôobtenir un affichage tr√®s d√©taill√©, utile pour voir les paquets ICMP (qui signalent les erreurs comme TTL expir√©).
√âtape 2 ‚Äì A√©rer le fichier pour faciliter la lecture avec sed

[dialloa@vm-dialloa ~]$ sed '/^IP /G' tracepath-trace.txt > tracepath-clean.txt

Explication :
Cette commande ins√®re une ligne vide entre chaque ligne commen√ßant par "IP " dans le fichier. Cela permet de rendre la lecture du fichier plus claire, surtout quand on a beaucoup de paquets ICMP.
√âtape 3 ‚Äì Rechercher les messages ICMP TTL exceeded (temps expir√©)

[dialloa@vm-dialloa ~]$ grep "ICMP time exceeded in-transit" tracepath-clean.txt

Explication :
Cette commande extrait uniquement les paquets ICMP qui disent :

    "Le TTL du paquet est arriv√© √† z√©ro chez moi, donc je l‚Äôai supprim√©."

Chaque message correspond √† un routeur rencontr√© par tracepath. On peut ainsi identifier les routeurs qui ont r√©pondu pendant le trajet.
üß™ Sous-questions d‚Äôanalyse
‚úÖ (a) Identifier le routeur H (celui qui n‚Äôappara√Æt qu‚Äôune seule fois)

[dialloa@vm-dialloa ~]$ grep "ICMP time exceeded in-transit" tracepath-clean.txt | cut -d ' ' -f 3 | sort | uniq -c

Explication :
On compte combien de fois chaque adresse IP appara√Æt dans les r√©ponses ICMP.
Le routeur H est celui qui n‚Äôappara√Æt qu‚Äôune seule fois, donc qui n‚Äôa r√©pondu qu‚Äô√† un seul TTL.
‚úÖ (b) Avec quel TTL ces paquets ont-ils √©t√© √©mis ?

[dialloa@vm-dialloa ~]$ grep ttl tracepath-clean.txt

Explication :
On cherche les valeurs ttl dans les paquets envoy√©s.
Chaque paquet tracepath est envoy√© avec un TTL diff√©rent (1, puis 2, puis 3‚Ä¶), pour que chaque routeur r√©ponde √† un moment diff√©rent.
Comparer le TTL avec la position du routeur H dans la sortie tracepath.
(c) Quelle valeur de TTL √† l‚Äôarriv√©e en H ?

Pas besoin de commande, on le d√©duit :

Explication :
Si le routeur H renvoie "ICMP time exceeded", c‚Äôest que le paquet est arriv√© avec TTL = 0.
C‚Äôest automatique : ICMP time exceeded = TTL expir√© = valeur de TTL √† l‚Äôarriv√©e = 0.

[dialloa@vm-dialloa ~]$ grep "ICMP" tracepath-clean.txt

Explication :
On cherche tous les paquets ICMP visibles dans la trace.
On peut voir :

    ICMP echo reply > r√©ponse √† un ping

    ICMP destination unreachable > machine inaccessible

    ICMP redirect > autre chemin sugg√©r√©

Chaque message ICMP a une signification sp√©cifique. Tu peux te r√©f√©rer au RFC 792 si tu veux aller plus loin.