### **Résumé du TP08 : Scripts Shell**

---

#### **1. La commande `seq` et ses équivalents**
- **Commande `seq`** : Génère une séquence de nombres incrémentée.
  - Exemple :  
    ```bash
    seq 5  # Affiche : 1 2 3 4 5
    seq 7  # Affiche : 1 2 3 4 5 6 7
    ```

- **Équivalent avec une boucle `for`** :
  - Pour reproduire `seq 5` :
    ```bash
    for i in {1..5}; do echo $i; done
    ```
  - Pour reproduire `seq 7` :
    ```bash
    for i in {1..7}; do echo $i; done
    ```

---

#### **2. Script `my_seq.sh`**
- Écrit un script qui reproduit la commande `seq` avec un argument entier positif.
- **Structure de `my_seq.sh`** :
  - Vérifie que l'argument est un entier positif.
  - Génère une séquence avec une boucle `for`.

**Exemple :**
```bash
#!/bin/bash

if [[ $# -ne 1 ]] || [[ $1 -lt 1 ]]; then
    echo "Usage: $0 <entier_positif>"
    exit 1
fi

for i in $(seq 1 $1); do
    echo $i
done
```

---

#### **3. Script `mult_mat.sh`**
- Affiche une **matrice de multiplication** pour les nombres de `{ARG1, ARG1+1, ..., ARG2}`.
- Si un seul argument est fourni, `ARG1` et `ARG2` sont égaux.

**Exemple :**
```bash
#!/bin/bash

if [[ $# -ne 2 ]] || [[ $1 -le 0 ]] || [[ $2 -le 0 ]] || [[ $1 -gt $2 ]]; then
    echo "Usage: $0 <NUM_ARG1> <NUM_ARG2>"
    exit 1
fi

for i in $(seq $1 $2); do
    for j in $(seq $1 $2); do
        printf "%-4d" $((i * j))
    done
    echo
done
```

**Exécution :**
```bash
./mult_mat.sh 7 11
```
**Résultat :**
```
49  56  63  70  77
56  64  72  80  88
63  72  81  90  99
70  80  90  100 110
77  88  99  110 121
```

---

#### **4. Conversion IPv4 binaire → décimale**
- Lecture des adresses IPv4 binaires dans un fichier, écriture des résultats en notation décimale.

**a. Script `bin2dot-with-for.sh` :**
- Utilise une boucle `for` pour traiter chaque ligne du fichier source.
- Vérifie si le fichier de destination existe et demande confirmation pour écraser.

**Exemple :**
```bash
#!/bin/bash

if [[ $# -ne 2 ]]; then
    echo "Usage: $0 <SRC_FILE> <DEST_FILE>"
    exit 1
fi

if [[ -f $2 ]]; then
    read -p "$2 exists. Overwrite? Yes/No --> " confirm
    if [[ $confirm != "Yes" ]]; then
        exit 1
    fi
fi

> $2
for addr in $(cat $1); do
    printf "%d.%d.%d.%d\n" $((2#${addr:0:8})) $((2#${addr:8:8})) $((2#${addr:16:8})) $((2#${addr:24:8})) >> $2
done
```

**b. Script `bin2dot-with-read.sh` :**
- Utilise une boucle `while` avec `read` pour lire les lignes une par une.
- Fonctionne comme `bin2dot-with-for.sh`, mais utilise `read` pour affecter les variables.

**Exemple :**
```bash
#!/bin/bash

if [[ $# -ne 2 ]]; then
    echo "Usage: $0 <SRC_FILE> <DEST_FILE>"
    exit 1
fi

if [[ -f $2 ]]; then
    read -p "$2 exists. Overwrite? Yes/No --> " confirm
    if [[ $confirm != "Yes" ]]; then
        exit 1
    fi
fi

> $2
while read -r addr; do
    printf "%d.%d.%d.%d\n" $((2#${addr:0:8})) $((2#${addr:8:8})) $((2#${addr:16:8})) $((2#${addr:24:8})) >> $2
done < $1
```

---

#### **5. La commande `read`**
- **Fonctionnement interactif :**
  - Exemple 1 : Lecture d'une valeur :
    ```bash
    read x
    echo "$? x=$x"
    ```
    Résultat : `$?` vaut 0 si la commande réussit, et `x` contient la valeur saisie.

  - Exemple 2 : Lecture sans saisir de valeur :
    - Tapez directement `<CR>` (Entrée) :
      ```
      echo "$? x=$x"
      ```
      Résultat : `$?` vaut 0, mais `x` est vide.

  - Exemple 3 : Lecture avec `CTRL+D` (fin de fichier) :
      ```
      echo "$? x=$x"
      ```
      Résultat : `$?` vaut 1 (indique la fin du fichier).

- **Utilisation dans un script** :
  - Permet de lire des variables ligne par ligne à partir d'un fichier.

---

### **Résumé des scripts produits :**
1. **`my_seq.sh`** : Reproduit `seq` pour un entier positif.
2. **`mult_mat.sh`** : Génère une matrice de multiplication.
3. **`bin2dot-with-for.sh`** : Convertit les adresses IPv4 binaires en décimales avec `for`.
4. **`bin2dot-with-read.sh`** : Convertit les adresses IPv4 binaires en décimales avec `while` et `read`.

Ces scripts combinent des concepts de base (boucles, conditions, gestion de fichiers) pour automatiser des tâches courantes en ligne de commande.